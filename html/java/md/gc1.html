<!DOCTYPE html>
<html>

<head>
    <title>MarkdownPad Document</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../css/md.css">
</head>

<body>
    <div>
        <table>
            <tr>
                <td><b>创建时间：</b></td>
                <td><i>2020/1/19 10:18</i></td>
            </tr>
            <tr>
                <td><b>更新时间：</b></td>
                <td><i>2020/4/3 20:31</i></td>
            </tr>
            <tr>
                <td><b>作者：</b></td>
                <td><i>lzr</i></td>
            </tr>
        </table>
    </div>
    <h1 id="java-gc-">java中的垃圾回收（GC）机制</h1>
    <blockquote>
        <p>Java语言有一个重要特性就是自动的垃圾回收，自动垃圾回收可以使得我们不用再像c/c++中疲于手动管理内存<br>那自动垃圾回收是如何工作的呢？<br>很多老师讲课、网上的视频和培训班只会讲一些很基础的概念，而不会对GC进行深入的讲解。<br>本文参考周志明老师作的《深入理解java虚拟机》第二版。<br>文中描述仅针对jdk8之前有效。
        </p>
    </blockquote>
    <hr>
    <h3 id="-garbage-collection-">垃圾收集（Garbage Collection）需要考虑的有什么？</h3>
    <ul>
        <li>回收谁</li>
        <li>什么时候回收</li>
        <li>怎么回收</li>
    </ul>
    <hr>
    <h3 id="-">回收谁</h3>
    <p>所谓的“垃圾”，其实就是指内存中已经“死”掉的对象，“死掉的”对象不会再经过任何途径被使用。<br>比如一些临时的对象，它创建完成后可能只使用一两次就再也不会被使用。<br>GC要做的工作，就是把这些已死的对象清理掉。</p>
    <hr>
    <h3 id="-">什么时候回收</h3>
    <p>那如何判断一个对象已死呢？</p>
    <h4 id="-">两种判断算法</h4>
    <ul>
        <li>引用计数法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就+1，引用失效时，计数器-1.任何时刻计数器为0的对象就是不可能再被引用的。<br> 缺点：不好解决对象间相互引用的问题。<br> exm:
        </li>
    </ul>
    <pre><code class="lang-java">public class Main {
    Main anomain;
    public static void main(String[] args) {
        Main m1 = new Main(); 
        Main m2 = new Main(); 
        m1.anomain = m2; 
        m2.anomain = m1; 
        m1 = null;
        m2 = null;
    }
}
</code></pre>
    <p>这样的情况下，m1 和 m2 互相引用，使用引用计数法就无法正常回收这部分内存了。</p>
    <ul>
        <li>可达性分析：<ul>
                <li>而在主流的商业语言中，GC通常由可达性分析来实现。在这种模式中，它的基本思路就是，以一些成为“GC
                    roots”的对象作为起始点，然后从这些节点开始搜索，搜索的路径叫做引用链，在引用链上的对象是可达的，而不在引用链上的对象不可达。<br>如下图所示：<br><img
                        src="gc1_files/可达性分析.png" alt="1"><br>在上面例子中的两个对象虽然互相引用，但是从GC roots并不能达到目的地。</li>
                <li>GC Roots一般有如下几种：<ul>
                        <li>本地变量表中的引用的对象</li>
                        <li>方法区中的静态属性引用的变量</li>
                        <li>方法区中常量引用的变量</li>
                        <li>本地变量表中引用的变量 </li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>
    <h4 id="-">引用</h4>
    <p>我们所熟知的引用一般为这种<br><code>String s =  new String();</code>
    在这种引用里，只要s还在生命周期内，s指向的String对象就不会被回收。<br>
        但是这一种引用有一个后果就是，如何描述一些可存在可不存在，或者说没那么重要的对象时，就会很无力。jdk为我们提供了其他的方式来描述这些对象：</p>
    <li>强引用： 类似上面语句</li>
    <li>软引用： 用来描述还有用但非必须的对象</li>
    <li>弱引用： 用来描述非必须对象，但是比软引用更弱</li>
    <li>虚引用： 最弱的引用方式<br>有关引用的类型，可以看我接下来几天会写的一篇文章，本文的重点在于GC。</li>
    <h4 id="-">对象自救</h4>
    <p>在finalize方法中，对象可以把自己挂到别的指针的引用上，可以实现一次自救。<br>但是finallize方法是一种不被推荐的使用方式。在接下来几天的文章中我会解释。</p>
    <h4 id="-">回收方法区</h4>
    <p>一些人也喜欢把方法区叫做永久代，java虚拟机规范中也说方法区可以不进行垃圾收集，因为对方法区进行GC的性价比可能不高。<br>方法区的垃圾主要有废弃常量和无用的类。</p>
    <ul>
        <li>废弃常量：<br>当没有任何变量指向这个常量的时候，这个常量就会被GC掉。常量池中的方法，接口，字段符号的引用和这个也相似。</li>
        <li>无用的类：<ul>
                <li>该类没有实例（都被回收）</li>
                <li>加载该类的Class Loader已被回收</li>
                <li>该类对应的class对象没有被引用</li>
            </ul>
        </li>
    </ul>
    <p>这个时候虚拟机就可以对这些常量和无用的类进行回收。<br>学习过spring框架的都知道，spring大量使用反射，动态代理机制。在这种情况下会产生很多无用的类。因此对方法区的回收还是有必要的。</p>
    <h3 id="-gc-">怎么回收（简单的GC算法）</h3>
    <h4 id="-">标记——清除法</h4>
    <p>这种算法会把需要清理的对象标记，如下图所示<br>黑色为需要清理的，黄色为存活的，空白为可用空间<br><img src="gc1_files/Image.png"
            alt="2"><br>在清理完后会变成这样：<br><img src="gc1_files/Image [1].png" alt="3"><br>也就是把黑色部分直接释放掉，不对其他的空间进行操作。</p>
    <p>但是这样就会导致两个问题：</p>
    <ul>
        <li>碎片空间，很容易再次不够用，再次触发GC</li>
        <li>效率不高，因为垃圾实际上远远比可用对象多很多，这样的情况下会有大量的清除工作，效率很低。</li>
    </ul>
    <h4 id="-">复制算法</h4>
    <p>为了解决效率问题，采用这种算法可以显著改善。<br>如下图所示：<br><img src="gc1_files/Image [2].png"
            alt="4"><br>左侧是回收前，右侧是回收后的。这种算法把内存分成两份，每次清理的时候，把左侧的存活对象复制到右侧，此时左侧全都为空的空间。下一次则把右侧的复制到左边来。
    </p>
    <h4 id="-">标记——整理算法</h4>
    <p>复制收集算法在对象存活率高的时候效率会很低，更关键的是，复制算法会直接浪费50%的空间，如果不想浪费这么多，就需要额外的空间进行担保，用来应对大量对象存活的极端情况。<br>根据老年代的特点，有人提出了“标记——整理”算法。标记过程和标记——清除法类似，但是后续直接把可用的对象向一侧挪动，然后直接清理掉边界之外的全部内存。<br>如下图所示：<br><img
            src="gc1_files/Image [3].png" alt="5"></p>
    <h4 id="-">分代收集算法</h4>
    <p>当前商用VM都采用分代收集的方式，其中一个非常典型的分代方式如图所示：<br><img src="gc1_files/Image [4].png" alt="6"></p>
    <ul>
        <li>研究表明大部分对象是朝生夕死的，所以不用按照在复制算法中1:1来分配。默认情况下，内存被分配成8:1（新生代/存活代），而剩下的则用作担保，分配到老年代。<br>新创建的对象放在新生代（Eden）中，第一次GC后存活的对象放进存活代（Survivor）中，每个存活的对象都会有一个年龄（每经历一次GC就涨一岁），<br>下一次GC的时候，survivor代中继续存活的对象以及eden代存活的对象，就放入另外一个survivor代中。此时这个survivor代以及eden代内存清空。<br><img
                src="gc1_files/gc分代.png" alt="7"><br>当一些对象年龄太大的时候，就放进老年代。老年代中的对象如果变成垃圾，那么老年代一般使用标记——整理算法，不同的垃圾收集器策略不同。
        </li>
    </ul>
    <h3 id="stop-the-world">stop the world</h3>
    <p>一定有人听过这个词，但是这个是什么意思呢？<br>实际上GC和妈妈打扫房间一样。假设一个场景，你是一只哈士奇，你在房间里不停地咬卫生纸，撕的满地纸屑。主人打扫的时候肯定会把你抓起来再打扫，而不是你一边生产垃圾，主人一边扫地。<br>在GC中也是一样。在可达性分析的过程中，如果某个对象突然变成垃圾，或者突然创建了一些对象，垃圾收集器就需要费很大的力气一直计算。<br>所以在垃圾收集的过程中，最好有这种情况出现。因此GC的时候需要停止一切能对对象引用状态产生影响的线程。<br><strong>这个过程称为STW（stop
            the
            world）</strong><br>这个过程怎么实现呢？当垃圾收集器开始工作的时候，所有线程必须到达一个安全的地方，这个点被称为safepoint，即此时开始收集垃圾是安全的。安全点的选择基本上是以程序“是否具有让程序长时间执行的特征”为标准而选定的，最明显的例子就是指令序列复用，例如方法调用，循环跳转，这些地方才会产生safepoint。<br>但是GC发生时，不可能所有的线程都刚好到safepoint。一种办法是先把所有线程停掉，然后把需要运行的线程运行到safepoint。<br>另外一种方法则是，在需要gc的时候设置一个标志，各个线程执行的时候检测到这个标志，自己把自己中断挂起。
    </p>
    <p>但是有些线程在不执行的时候，比如处于sleep状态或block状态的时候，它是无法响应cpu的指令的，总不能一直等到这些线程恢复再进场GC。这时候可以通safe
        region（安全区域）来实现。当一个线程运行到一个不会对对象的引用关系造成影响的地方时，在这个区域内的任何时候GC都是安全的。JVM进行GC的时候，发现某个线程在安全区域内，就不用理会这个线程的状态。</p>
    <h3 id="-">总结</h3>
    <p>到此，简单介绍了jvm垃圾收集的一些原理和方法，但是实际上还停留在理论阶段。商用jvm使用了很多种垃圾收集器。包括如何对垃圾收集进行优化，这些都还没有涉及。预计下周六可以更新出来。</p>

</body>

</html>